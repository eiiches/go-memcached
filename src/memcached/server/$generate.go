// +build generate
//go:generate go run $GOFILE

package main

import "fmt"
import "os/exec"
import "os"
import "gopkg.in/yaml.v2"
import "text/template"
import "io/ioutil"
import "strings"
import "bytes"

func snakeToUpperCamel(word string) string {
	var buffer bytes.Buffer

	capitalize := true
	for i := 0; i < len(word); i++ {
		if word[i] == '_' {
			capitalize = true
			continue
		}
		if capitalize {
			ch := strings.ToUpper(string(word[i]))
			buffer.WriteString(ch)
			capitalize = false
		} else {
			buffer.WriteString(string(word[i]))
			capitalize = false
		}
	}

	return buffer.String()
}

func isTrue(value interface{}) bool {
	switch t := value.(type) {
	case bool:
		return t
	default:
		return false
	}
}

func loadConfig() map[interface{}]interface{} {
	config, err := ioutil.ReadFile("$generate.yml")
	if err != nil {
		panic(err)
	}

	m := make(map[interface{}]interface{})
	err = yaml.Unmarshal(config, &m)
	if err != nil {
		panic(err)
	}
	return m
}

func main() {
	config := loadConfig()

	cwd, err := os.Open(".")
	if err != nil {
		panic(err)
	}
	defer cwd.Close()

	files, err := cwd.Readdir(-1)
	if err != nil {
		panic(err)
	}

	for _, file := range files {
		fname := file.Name()
		if !strings.HasSuffix(fname, ".go.in") {
			continue
		}

		in, err := ioutil.ReadFile(fname)
		if err != nil {
			panic(err)
		}

		t := template.Must(template.New("$generate").Funcs(template.FuncMap{
			"snakeToUpperCamel": snakeToUpperCamel,
			"isTrue":            isTrue,
		}).Parse(string(in)))

		cmd := exec.Command("gofmt")
		fmtin, _ := cmd.StdinPipe()
		fmtout, err := cmd.StdoutPipe()
		if err != nil {
			fmt.Println(err)
		}
		cmd.Start()
		if err = t.Execute(fmtin, config); err != nil {
			panic(err)
		}
		fmtin.Close()
		source, _ := ioutil.ReadAll(fmtout)
		cmd.Wait()

		out, err := os.Create(fname[:len(fname)-3])
		if err != nil {
			panic(err)
		}
		defer out.Close()

		out.WriteString("// DO NOT EDIT THIS FILE\n")
		out.WriteString("// This file is generated from " + fname + "\n")
		out.WriteString("\n")
		out.WriteString(string(source))

	}
}
