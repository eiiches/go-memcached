// +build !generate

package memcached

import "os"
import "fmt"
import "encoding/binary"

type parseRequestFunc func(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error)

func parseRequestFuncTable() []parseRequestFunc {
	return []parseRequestFunc{
{{range $command := .binary_commands}}		parse{{$command.name}}Request, // {{$command.opcode}}
{{end}}	}
}

{{range $command := .binary_commands}}
func parse{{$command.name}}Request(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) {{if $command.request.has_key}}=={{else}}>{{end}} 0 {
		return nil, fmt.Errorf({{if $command.request.has_key}}"{{$command.name}} MUST have key"{{else}}"{{$command.name}} MUST NOT have key"{{end}})
	}

	if len(value) {{if $command.request.has_value}}=={{else}}>{{end}} 0 {
		return nil, fmt.Errorf({{if $command.request.has_value}}"{{$command.name}} MUST have value"{{else}}"{{$command.name}} MUST NOT have value"{{end}})
	}

	{{if $command.request.has_extras}}
		{{if $command.request.has_extras | isTrue}}
			if len(extras) == 0 {
				return nil, fmt.Errorf("{{$command.name}} MUST have extras")
			}
		{{else}}
			if len(extras) != {{$command.request.has_extras.size}} {
			return nil, fmt.Errorf("{{$command.name}} MUST have extras of exactly {{$command.request.has_extras.size}} bytes")
			}
		{{end}}
	{{else}}
		if len(extras) > 0 {
			return nil, fmt.Errorf("{{$command.name}} MUST NOT have extras")
		}
	{{end}}

	{{if $command.request.has_magic}}
		magic := binary.BigEndian.Uint32(extras[{{$command.request.has_magic.offset}}:])
		if magic != MAGIC_DEADBEEF {
			fmt.Fprintf(os.Stderr, "Invalid magic for {{$command.name}}: %+v\n", magic)
			// return nil, fmt.Errorf("Invalid magic for {{$command.name}}: %+v", magic)
		}
	{{end}}

	{{range $extra := $command.request.extras}}
		{{$extra.var}} := binary.BigEndian.{{$extra.type}}(extras[{{$extra.offset}}:])
	{{end}}

	command := {{or $command.request.command.name $command.name}}({{if $command.request.has_key}}key{{if $command.request.has_value}}, value{{end}}{{end}}{{range $arg := $command.request.command.extra_args}}, {{$arg}}{{end}})

	{{if $command.request.has_expire}}
		command.WithExpire(binary.BigEndian.Uint32(extras[{{$command.request.has_expire.offset}}:]))
	{{end}}
	{{if $command.request.has_cas}}
		command.WithCas(header.cas)
		{{end}}
	{{range $key, $value := $command.request.command.options}}
		command.{{$key | snakeToUpperCamel}}({{$value}})
	{{end}}

	return command, nil
}
{{end}}
