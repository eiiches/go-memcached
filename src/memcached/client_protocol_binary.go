// DO NOT EDIT THIS FILE
// This file is generated from client_protocol_binary.go.in

// +build !generate

package memcached

import "io"
import "fmt"
import "encoding/binary"

func sendRequest(cli *MemcachedClient, header *binaryRequestHeader, key []byte, value []byte, extra []byte) {
	var buf [BINARY_HEADER_BYTES]byte
	header.write(buf[:])

	cli.conn.Write(buf[:])
	if key != nil {
		cli.conn.Write(key)
	}
	if value != nil {
		cli.conn.Write(value)
	}
	if extra != nil {
		cli.conn.Write(extra)
	}
}

func recvResponse(cli *MemcachedClient) (*binaryResponseHeader, []byte, []byte, []byte, error) {
	var header binaryResponseHeader
	var headerBuf [BINARY_HEADER_BYTES]byte

	if _, err := io.ReadFull(cli.conn, headerBuf[:]); err != nil {
		return nil, nil, nil, nil, err
	}

	header.read(headerBuf[:])
	if header.magic != BINARY_MAGIC_RESPONSE {
		return nil, nil, nil, nil, fmt.Errorf("invalid magic %+v", header.magic)
	}

	bodyBuf := make([]byte, header.totalBodyLength)
	if _, err := io.ReadFull(cli.conn, bodyBuf); err != nil {
		return nil, nil, nil, nil, err
	}

	offset := 0
	extras := bodyBuf[offset : offset+int(header.extrasLength)]
	offset += int(header.extrasLength)
	key := bodyBuf[offset : offset+int(header.keyLength)]
	offset += int(header.keyLength)
	value := bodyBuf[offset:header.totalBodyLength]

	return &header, key, value, extras, nil
}

func (cli *MemcachedClient) Add(key []byte, value []byte, opts *AddOptions) (uint64, error) {
	theader, tkey, tvalue, textra := formatAddRequest(key, value, opts)
	sendRequest(cli, theader, tkey, tvalue, textra)
	rheader, rkey, rvalue, rextra, rerr := recvResponse(cli)
	if rerr != nil {
		return 0, rerr
	}
	return parseAddResponse(rheader, rkey, rvalue, rextra)
}

func (cli *MemcachedClient) Replace(key []byte, value []byte, opts *ReplaceOptions) (uint64, error) {
	theader, tkey, tvalue, textra := formatReplaceRequest(key, value, opts)
	sendRequest(cli, theader, tkey, tvalue, textra)
	rheader, rkey, rvalue, rextra, rerr := recvResponse(cli)
	if rerr != nil {
		return 0, rerr
	}
	return parseReplaceResponse(rheader, rkey, rvalue, rextra)
}

func (cli *MemcachedClient) Get(key []byte, opts *GetOptions) ([]byte, uint32, uint64, error) {
	theader, tkey, tvalue, textra := formatGetRequest(key, opts)
	sendRequest(cli, theader, tkey, tvalue, textra)
	rheader, rkey, rvalue, rextra, rerr := recvResponse(cli)
	if rerr != nil {
		return nil, 0, 0, rerr
	}
	return parseGetResponse(rheader, rkey, rvalue, rextra)
}

func (cli *MemcachedClient) Increment(key []byte, amount uint64, initial uint64, opts *IncrementOptions) ([]byte, uint64, error) {
	theader, tkey, tvalue, textra := formatIncrementRequest(key, amount, initial, opts)
	sendRequest(cli, theader, tkey, tvalue, textra)
	rheader, rkey, rvalue, rextra, rerr := recvResponse(cli)
	if rerr != nil {
		return nil, 0, rerr
	}
	return parseIncrementResponse(rheader, rkey, rvalue, rextra)
}

func (cli *MemcachedClient) Decrement(key []byte, amount uint64, initial uint64, opts *DecrementOptions) ([]byte, uint64, error) {
	theader, tkey, tvalue, textra := formatDecrementRequest(key, amount, initial, opts)
	sendRequest(cli, theader, tkey, tvalue, textra)
	rheader, rkey, rvalue, rextra, rerr := recvResponse(cli)
	if rerr != nil {
		return nil, 0, rerr
	}
	return parseDecrementResponse(rheader, rkey, rvalue, rextra)
}

func (cli *MemcachedClient) Set(key []byte, value []byte, opts *SetOptions) (uint64, error) {
	theader, tkey, tvalue, textra := formatSetRequest(key, value, opts)
	sendRequest(cli, theader, tkey, tvalue, textra)
	rheader, rkey, rvalue, rextra, rerr := recvResponse(cli)
	if rerr != nil {
		return 0, rerr
	}
	return parseSetResponse(rheader, rkey, rvalue, rextra)
}

func (cli *MemcachedClient) Delete(key []byte, opts *DeleteOptions) error {
	theader, tkey, tvalue, textra := formatDeleteRequest(key, opts)
	sendRequest(cli, theader, tkey, tvalue, textra)
	rheader, rkey, rvalue, rextra, rerr := recvResponse(cli)
	if rerr != nil {
		return rerr
	}
	return parseDeleteResponse(rheader, rkey, rvalue, rextra)
}

func (cli *MemcachedClient) Append(key []byte, value []byte, opts *AppendOptions) error {
	theader, tkey, tvalue, textra := formatAppendRequest(key, value, opts)
	sendRequest(cli, theader, tkey, tvalue, textra)
	rheader, rkey, rvalue, rextra, rerr := recvResponse(cli)
	if rerr != nil {
		return rerr
	}
	return parseAppendResponse(rheader, rkey, rvalue, rextra)
}

func (cli *MemcachedClient) Prepend(key []byte, value []byte, opts *PrependOptions) error {
	theader, tkey, tvalue, textra := formatPrependRequest(key, value, opts)
	sendRequest(cli, theader, tkey, tvalue, textra)
	rheader, rkey, rvalue, rextra, rerr := recvResponse(cli)
	if rerr != nil {
		return rerr
	}
	return parsePrependResponse(rheader, rkey, rvalue, rextra)
}

func (cli *MemcachedClient) Flush(opts *FlushOptions) error {
	theader, tkey, tvalue, textra := formatFlushRequest(opts)
	sendRequest(cli, theader, tkey, tvalue, textra)
	rheader, rkey, rvalue, rextra, rerr := recvResponse(cli)
	if rerr != nil {
		return rerr
	}
	return parseFlushResponse(rheader, rkey, rvalue, rextra)
}

func (cli *MemcachedClient) Nop(opts *NopOptions) error {
	theader, tkey, tvalue, textra := formatNopRequest(opts)
	sendRequest(cli, theader, tkey, tvalue, textra)
	rheader, rkey, rvalue, rextra, rerr := recvResponse(cli)
	if rerr != nil {
		return rerr
	}
	return parseNopResponse(rheader, rkey, rvalue, rextra)
}

func (cli *MemcachedClient) Quit(opts *QuitOptions) error {
	theader, tkey, tvalue, textra := formatQuitRequest(opts)
	sendRequest(cli, theader, tkey, tvalue, textra)
	rheader, rkey, rvalue, rextra, rerr := recvResponse(cli)
	if rerr != nil {
		return rerr
	}
	return parseQuitResponse(rheader, rkey, rvalue, rextra)
}

func (cli *MemcachedClient) Version(opts *VersionOptions) error {
	theader, tkey, tvalue, textra := formatVersionRequest(opts)
	sendRequest(cli, theader, tkey, tvalue, textra)
	rheader, rkey, rvalue, rextra, rerr := recvResponse(cli)
	if rerr != nil {
		return rerr
	}
	return parseVersionResponse(rheader, rkey, rvalue, rextra)
}

func (cli *MemcachedClient) Stat(opts *StatOptions) error {
	theader, tkey, tvalue, textra := formatStatRequest(opts)
	sendRequest(cli, theader, tkey, tvalue, textra)
	rheader, rkey, rvalue, rextra, rerr := recvResponse(cli)
	if rerr != nil {
		return rerr
	}
	return parseStatResponse(rheader, rkey, rvalue, rextra)
}

func (cli *MemcachedClient) GetWithKey(key []byte, opts *GetWithKeyOptions) ([]byte, []byte, uint32, uint64, error) {
	theader, tkey, tvalue, textra := formatGetWithKeyRequest(key, opts)
	sendRequest(cli, theader, tkey, tvalue, textra)
	rheader, rkey, rvalue, rextra, rerr := recvResponse(cli)
	if rerr != nil {
		return nil, nil, 0, 0, rerr
	}
	return parseGetWithKeyResponse(rheader, rkey, rvalue, rextra)
}

func formatGetRequest(key []byte, opts *GetOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	const extralen = 0

	header := &binaryRequestHeader{
		magic:           BINARY_MAGIC_REQUEST,
		opcode:          0,
		keyLength:       uint16(len(key)),
		extrasLength:    extralen,
		totalBodyLength: uint32(extralen + len(key)),
	}
	return header, key, nil, nil
}

func parseGetResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) ([]byte, uint32, uint64, *MemcachedError) {

	rcas := header.cas

	rflags := binary.BigEndian.Uint32(extra[0:])

	return value, rflags, rcas, nil

}

func formatSetRequest(key []byte, value []byte, opts *SetOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	flags := opts.Flags
	cas := opts.Cas
	expire := opts.Expire

	const extralen = 8
	var extrabuf [extralen]byte

	binary.BigEndian.PutUint32(extrabuf[0:], flags)

	binary.BigEndian.PutUint32(extrabuf[4:], expire)

	header := &binaryRequestHeader{
		magic:           BINARY_MAGIC_REQUEST,
		opcode:          1,
		keyLength:       uint16(len(key)),
		extrasLength:    extralen,
		totalBodyLength: uint32(extralen + len(key) + len(value)),
		cas:             cas,
	}
	return header, key, value, extrabuf[:]
}

func parseSetResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) (uint64, *MemcachedError) {

	rcas := header.cas

	return rcas, nil

}

func formatAddRequest(key []byte, value []byte, opts *AddOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	flags := opts.Flags
	cas := opts.Cas
	expire := opts.Expire

	const extralen = 8
	var extrabuf [extralen]byte

	binary.BigEndian.PutUint32(extrabuf[0:], flags)

	binary.BigEndian.PutUint32(extrabuf[4:], expire)

	header := &binaryRequestHeader{
		magic:           BINARY_MAGIC_REQUEST,
		opcode:          2,
		keyLength:       uint16(len(key)),
		extrasLength:    extralen,
		totalBodyLength: uint32(extralen + len(key) + len(value)),
		cas:             cas,
	}
	return header, key, value, extrabuf[:]
}

func parseAddResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) (uint64, *MemcachedError) {

	rcas := header.cas

	return rcas, nil

}

func formatReplaceRequest(key []byte, value []byte, opts *ReplaceOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	flags := opts.Flags
	cas := opts.Cas
	expire := opts.Expire

	const extralen = 8
	var extrabuf [extralen]byte

	binary.BigEndian.PutUint32(extrabuf[0:], flags)

	binary.BigEndian.PutUint32(extrabuf[4:], expire)

	header := &binaryRequestHeader{
		magic:           BINARY_MAGIC_REQUEST,
		opcode:          3,
		keyLength:       uint16(len(key)),
		extrasLength:    extralen,
		totalBodyLength: uint32(extralen + len(key) + len(value)),
		cas:             cas,
	}
	return header, key, value, extrabuf[:]
}

func parseReplaceResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) (uint64, *MemcachedError) {

	rcas := header.cas

	return rcas, nil

}

func formatDeleteRequest(key []byte, opts *DeleteOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	cas := opts.Cas

	const extralen = 0

	header := &binaryRequestHeader{
		magic:           BINARY_MAGIC_REQUEST,
		opcode:          4,
		keyLength:       uint16(len(key)),
		extrasLength:    extralen,
		totalBodyLength: uint32(extralen + len(key)),
		cas:             cas,
	}
	return header, key, nil, nil
}

func parseDeleteResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) *MemcachedError {

	return nil

}

func formatIncrementRequest(key []byte, amount uint64, initial uint64, opts *IncrementOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	cas := opts.Cas
	expire := opts.Expire

	const extralen = 20
	var extrabuf [extralen]byte

	binary.BigEndian.PutUint64(extrabuf[0:], amount)

	binary.BigEndian.PutUint64(extrabuf[8:], initial)

	binary.BigEndian.PutUint32(extrabuf[16:], expire)

	header := &binaryRequestHeader{
		magic:           BINARY_MAGIC_REQUEST,
		opcode:          5,
		keyLength:       uint16(len(key)),
		extrasLength:    extralen,
		totalBodyLength: uint32(extralen + len(key)),
		cas:             cas,
	}
	return header, key, nil, extrabuf[:]
}

func parseIncrementResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) ([]byte, uint64, *MemcachedError) {

	rcas := header.cas

	return value, rcas, nil

}

func formatDecrementRequest(key []byte, amount uint64, initial uint64, opts *DecrementOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	cas := opts.Cas
	expire := opts.Expire

	const extralen = 20
	var extrabuf [extralen]byte

	binary.BigEndian.PutUint64(extrabuf[0:], amount)

	binary.BigEndian.PutUint64(extrabuf[8:], initial)

	binary.BigEndian.PutUint32(extrabuf[16:], expire)

	header := &binaryRequestHeader{
		magic:           BINARY_MAGIC_REQUEST,
		opcode:          6,
		keyLength:       uint16(len(key)),
		extrasLength:    extralen,
		totalBodyLength: uint32(extralen + len(key)),
		cas:             cas,
	}
	return header, key, nil, extrabuf[:]
}

func parseDecrementResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) ([]byte, uint64, *MemcachedError) {

	rcas := header.cas

	return value, rcas, nil

}

func formatQuitRequest(opts *QuitOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	const extralen = 0

	header := &binaryRequestHeader{
		magic:  BINARY_MAGIC_REQUEST,
		opcode: 7,

		extrasLength:    extralen,
		totalBodyLength: uint32(extralen),
	}
	return header, nil, nil, nil
}

func parseQuitResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) *MemcachedError {

	return nil

}

func formatFlushRequest(opts *FlushOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	const extralen = 0

	header := &binaryRequestHeader{
		magic:  BINARY_MAGIC_REQUEST,
		opcode: 8,

		extrasLength:    extralen,
		totalBodyLength: uint32(extralen),
	}
	return header, nil, nil, nil
}

func parseFlushResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) *MemcachedError {

	return nil

}

func formatGetQRequest(key []byte, opts *GetOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	const extralen = 0

	header := &binaryRequestHeader{
		magic:           BINARY_MAGIC_REQUEST,
		opcode:          9,
		keyLength:       uint16(len(key)),
		extrasLength:    extralen,
		totalBodyLength: uint32(extralen + len(key)),
	}
	return header, key, nil, nil
}

func parseGetQResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) ([]byte, uint32, uint64, *MemcachedError) {

	rcas := header.cas

	rflags := binary.BigEndian.Uint32(extra[0:])

	return value, rflags, rcas, nil

}

func formatNopRequest(opts *NopOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	const extralen = 0

	header := &binaryRequestHeader{
		magic:  BINARY_MAGIC_REQUEST,
		opcode: 10,

		extrasLength:    extralen,
		totalBodyLength: uint32(extralen),
	}
	return header, nil, nil, nil
}

func parseNopResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) *MemcachedError {

	return nil

}

func formatVersionRequest(opts *VersionOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	const extralen = 0

	header := &binaryRequestHeader{
		magic:  BINARY_MAGIC_REQUEST,
		opcode: 11,

		extrasLength:    extralen,
		totalBodyLength: uint32(extralen),
	}
	return header, nil, nil, nil
}

func parseVersionResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) *MemcachedError {

	return nil

}

func formatGetWithKeyRequest(key []byte, opts *GetWithKeyOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	const extralen = 0

	header := &binaryRequestHeader{
		magic:           BINARY_MAGIC_REQUEST,
		opcode:          12,
		keyLength:       uint16(len(key)),
		extrasLength:    extralen,
		totalBodyLength: uint32(extralen + len(key)),
	}
	return header, key, nil, nil
}

func parseGetWithKeyResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) ([]byte, []byte, uint32, uint64, *MemcachedError) {

	rcas := header.cas

	rflags := binary.BigEndian.Uint32(extra[0:])

	return key, value, rflags, rcas, nil

}

func formatGetWithKeyQRequest(key []byte, opts *GetWithKeyOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	const extralen = 0

	header := &binaryRequestHeader{
		magic:           BINARY_MAGIC_REQUEST,
		opcode:          13,
		keyLength:       uint16(len(key)),
		extrasLength:    extralen,
		totalBodyLength: uint32(extralen + len(key)),
	}
	return header, key, nil, nil
}

func parseGetWithKeyQResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) ([]byte, []byte, uint32, uint64, *MemcachedError) {

	rcas := header.cas

	rflags := binary.BigEndian.Uint32(extra[0:])

	return key, value, rflags, rcas, nil

}

func formatAppendRequest(key []byte, value []byte, opts *AppendOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	cas := opts.Cas

	const extralen = 0

	header := &binaryRequestHeader{
		magic:           BINARY_MAGIC_REQUEST,
		opcode:          14,
		keyLength:       uint16(len(key)),
		extrasLength:    extralen,
		totalBodyLength: uint32(extralen + len(key) + len(value)),
		cas:             cas,
	}
	return header, key, value, nil
}

func parseAppendResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) *MemcachedError {

	return nil

}

func formatPrependRequest(key []byte, value []byte, opts *PrependOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	cas := opts.Cas

	const extralen = 0

	header := &binaryRequestHeader{
		magic:           BINARY_MAGIC_REQUEST,
		opcode:          15,
		keyLength:       uint16(len(key)),
		extrasLength:    extralen,
		totalBodyLength: uint32(extralen + len(key) + len(value)),
		cas:             cas,
	}
	return header, key, value, nil
}

func parsePrependResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) *MemcachedError {

	return nil

}

func formatStatRequest(opts *StatOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	const extralen = 0

	header := &binaryRequestHeader{
		magic:  BINARY_MAGIC_REQUEST,
		opcode: 16,

		extrasLength:    extralen,
		totalBodyLength: uint32(extralen),
	}
	return header, nil, nil, nil
}

func parseStatResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) *MemcachedError {

	return nil

}

func formatSetQRequest(key []byte, value []byte, opts *SetOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	flags := opts.Flags
	cas := opts.Cas
	expire := opts.Expire

	const extralen = 8
	var extrabuf [extralen]byte

	binary.BigEndian.PutUint32(extrabuf[0:], flags)

	binary.BigEndian.PutUint32(extrabuf[4:], expire)

	header := &binaryRequestHeader{
		magic:           BINARY_MAGIC_REQUEST,
		opcode:          17,
		keyLength:       uint16(len(key)),
		extrasLength:    extralen,
		totalBodyLength: uint32(extralen + len(key) + len(value)),
		cas:             cas,
	}
	return header, key, value, extrabuf[:]
}

func parseSetQResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) (uint64, *MemcachedError) {

	rcas := header.cas

	return rcas, nil

}

func formatAddQRequest(key []byte, value []byte, opts *AddOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	flags := opts.Flags
	cas := opts.Cas
	expire := opts.Expire

	const extralen = 8
	var extrabuf [extralen]byte

	binary.BigEndian.PutUint32(extrabuf[0:], flags)

	binary.BigEndian.PutUint32(extrabuf[4:], expire)

	header := &binaryRequestHeader{
		magic:           BINARY_MAGIC_REQUEST,
		opcode:          18,
		keyLength:       uint16(len(key)),
		extrasLength:    extralen,
		totalBodyLength: uint32(extralen + len(key) + len(value)),
		cas:             cas,
	}
	return header, key, value, extrabuf[:]
}

func parseAddQResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) (uint64, *MemcachedError) {

	rcas := header.cas

	return rcas, nil

}

func formatReplaceQRequest(key []byte, value []byte, opts *ReplaceOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	flags := opts.Flags
	cas := opts.Cas
	expire := opts.Expire

	const extralen = 8
	var extrabuf [extralen]byte

	binary.BigEndian.PutUint32(extrabuf[0:], flags)

	binary.BigEndian.PutUint32(extrabuf[4:], expire)

	header := &binaryRequestHeader{
		magic:           BINARY_MAGIC_REQUEST,
		opcode:          19,
		keyLength:       uint16(len(key)),
		extrasLength:    extralen,
		totalBodyLength: uint32(extralen + len(key) + len(value)),
		cas:             cas,
	}
	return header, key, value, extrabuf[:]
}

func parseReplaceQResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) (uint64, *MemcachedError) {

	rcas := header.cas

	return rcas, nil

}

func formatDeleteQRequest(key []byte, opts *DeleteOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	cas := opts.Cas

	const extralen = 0

	header := &binaryRequestHeader{
		magic:           BINARY_MAGIC_REQUEST,
		opcode:          20,
		keyLength:       uint16(len(key)),
		extrasLength:    extralen,
		totalBodyLength: uint32(extralen + len(key)),
		cas:             cas,
	}
	return header, key, nil, nil
}

func parseDeleteQResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) *MemcachedError {

	return nil

}

func formatIncrementQRequest(key []byte, amount uint64, initial uint64, opts *IncrementOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	cas := opts.Cas
	expire := opts.Expire

	const extralen = 20
	var extrabuf [extralen]byte

	binary.BigEndian.PutUint64(extrabuf[0:], amount)

	binary.BigEndian.PutUint64(extrabuf[8:], initial)

	binary.BigEndian.PutUint32(extrabuf[16:], expire)

	header := &binaryRequestHeader{
		magic:           BINARY_MAGIC_REQUEST,
		opcode:          21,
		keyLength:       uint16(len(key)),
		extrasLength:    extralen,
		totalBodyLength: uint32(extralen + len(key)),
		cas:             cas,
	}
	return header, key, nil, extrabuf[:]
}

func parseIncrementQResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) ([]byte, uint64, *MemcachedError) {

	rcas := header.cas

	return value, rcas, nil

}

func formatDecrementQRequest(key []byte, amount uint64, initial uint64, opts *DecrementOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	cas := opts.Cas
	expire := opts.Expire

	const extralen = 20
	var extrabuf [extralen]byte

	binary.BigEndian.PutUint64(extrabuf[0:], amount)

	binary.BigEndian.PutUint64(extrabuf[8:], initial)

	binary.BigEndian.PutUint32(extrabuf[16:], expire)

	header := &binaryRequestHeader{
		magic:           BINARY_MAGIC_REQUEST,
		opcode:          22,
		keyLength:       uint16(len(key)),
		extrasLength:    extralen,
		totalBodyLength: uint32(extralen + len(key)),
		cas:             cas,
	}
	return header, key, nil, extrabuf[:]
}

func parseDecrementQResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) ([]byte, uint64, *MemcachedError) {

	rcas := header.cas

	return value, rcas, nil

}

func formatQuitQRequest(opts *QuitOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	const extralen = 0

	header := &binaryRequestHeader{
		magic:  BINARY_MAGIC_REQUEST,
		opcode: 23,

		extrasLength:    extralen,
		totalBodyLength: uint32(extralen),
	}
	return header, nil, nil, nil
}

func parseQuitQResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) *MemcachedError {

	return nil

}

func formatFlushQRequest(opts *FlushOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	const extralen = 0

	header := &binaryRequestHeader{
		magic:  BINARY_MAGIC_REQUEST,
		opcode: 24,

		extrasLength:    extralen,
		totalBodyLength: uint32(extralen),
	}
	return header, nil, nil, nil
}

func parseFlushQResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) *MemcachedError {

	return nil

}

func formatAppendQRequest(key []byte, value []byte, opts *AppendOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	cas := opts.Cas

	const extralen = 0

	header := &binaryRequestHeader{
		magic:           BINARY_MAGIC_REQUEST,
		opcode:          25,
		keyLength:       uint16(len(key)),
		extrasLength:    extralen,
		totalBodyLength: uint32(extralen + len(key) + len(value)),
		cas:             cas,
	}
	return header, key, value, nil
}

func parseAppendQResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) *MemcachedError {

	return nil

}

func formatPrependQRequest(key []byte, value []byte, opts *PrependOptions) (*binaryRequestHeader, []byte, []byte, []byte) {

	cas := opts.Cas

	const extralen = 0

	header := &binaryRequestHeader{
		magic:           BINARY_MAGIC_REQUEST,
		opcode:          26,
		keyLength:       uint16(len(key)),
		extrasLength:    extralen,
		totalBodyLength: uint32(extralen + len(key) + len(value)),
		cas:             cas,
	}
	return header, key, value, nil
}

func parsePrependQResponse(header *binaryResponseHeader, key []byte, value []byte, extra []byte) *MemcachedError {

	return nil

}
