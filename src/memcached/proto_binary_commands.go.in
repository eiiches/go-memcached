// +build !generate

package memcached

import "os"
import "fmt"
import "encoding/binary"

type binaryRequestHandler func(cli Memcached, header *binaryRequestHeader, key []byte, value []byte, extras []byte) (rheader *binaryResponseHeader, rkey []byte, rvalue []byte, rextras []byte)

func binaryRequestHandlerTable() []binaryRequestHandler {
	return []binaryRequestHandler{
{{range $command := .binary_commands}}		handle{{$command.name}}Request, // {{$command.opcode}}
{{end}} }
}

func binaryErrorResponse(header *binaryRequestHeader, err *MemcachedError) (*binaryResponseHeader, []byte, []byte, []byte) {
	return &binaryResponseHeader{
			magic: MAGIC_RESPONSE,
			opaque: header.opaque,
			opcode: header.opcode,
			status: err.ErrorCode(),
	}, nil, nil, nil
}

{{range $op := .binary_commands}}
func handle{{$op.name}}Request(cli Memcached, header *binaryRequestHeader, key []byte, value []byte, extras []byte) (*binaryResponseHeader, []byte, []byte, []byte) {
	if len(key) {{if $op.request.has_key}}=={{else}}>{{end}} 0 {
		return binaryErrorResponse(header, newInvalidArgumentsError({{if $op.request.has_key}}"{{$op.name}} MUST have key"{{else}}"{{$op.name}} MUST NOT have key"{{end}}))
	}

	if len(value) {{if $op.request.has_value}}=={{else}}>{{end}} 0 {
		return binaryErrorResponse(header, newInvalidArgumentsError({{if $op.request.has_value}}"{{$op.name}} MUST have value"{{else}}"{{$op.name}} MUST NOT have value"{{end}}))
	}

	{{if $op.request.has_extras}}
		{{if $op.request.has_extras | isTrue}}
			if len(extras) == 0 {
				return binaryErrorResponse(header, newInvalidArgumentsError("{{$op.name}} MUST have extras"))
			}
		{{else}}
			if len(extras) != {{$op.request.has_extras.size}} {
			return binaryErrorResponse(header, newInvalidArgumentsError("{{$op.name}} MUST have extras of exactly {{$op.request.has_extras.size}} bytes"))
			}
		{{end}}
	{{else}}
		if len(extras) > 0 {
			return binaryErrorResponse(header, newInvalidArgumentsError("{{$op.name}} MUST NOT have extras"))
		}
	{{end}}

	{{if $op.request.has_magic}}
		magic := binary.BigEndian.Uint32(extras[{{$op.request.has_magic.offset}}:])
		if magic != MAGIC_DEADBEEF {
			fmt.Fprintf(os.Stderr, "Invalid magic for {{$op.name}}: %+v\n", magic)
			// return nil, fmt.Errorf("Invalid magic for {{$op.name}}: %+v", magic)
		}
	{{end}}

	{{range $extra := $op.request.extras}}
		{{$extra.var}} := binary.BigEndian.{{$extra.type}}(extras[{{$extra.offset}}:])
	{{end}}


	{{with $command := $op.command}}{{with $CommandName := $command.name | snakeToUpperCamel}}
		opts := &{{$CommandName}}Options{
			{{if $command.opts.has_expire}} Expire: binary.BigEndian.Uint32(extras[{{or $op.request.has_expire.offset "\"<NULL>\""}}:]), {{end}}
			{{if $command.opts.has_cas}} Cas: header.cas, {{end}}
			{{range $key, $value := $op.request.opts.extra}}
				{{$key | snakeToUpperCamel}}: {{$value}},
			{{end}}
		}
		{{if $command.returns.has_key}}rkey, {{end}}{{if $command.returns.has_value}}rvalue, {{end}}{{if $command.returns.has_flags}}rflags, {{end}}{{if $command.returns.has_cas}}rcas, {{end}}rerr := cli.{{$CommandName}}({{if $command.args.has_key}}key, {{end}}{{if $command.args.has_value}}value, {{end}}{{range $arg := $op.request.args.extra}}{{$arg}}, {{end}}opts)

		if rerr != nil {
			return binaryErrorResponse(header, rerr)
		}

		var extralen int
		{{if $op.response.extra_length}}{{if gt $op.response.extra_length 0}}
			var extrabuf [{{$op.response.extra_length}}]byte
			{{range $extra := $op.response.extra}}
				binary.BigEndian.Put{{$extra.type}}(extrabuf[{{$extra.offset}}:], {{$extra.name}})
			{{end}}
			extralen = {{$op.response.extra_length}}
		{{end}}{{end}}

		rheader := &binaryResponseHeader{
			magic: MAGIC_RESPONSE,
			opaque: header.opaque,
			opcode: header.opcode,
			{{if $command.returns.has_key}}keyLength: uint16(len(rkey)),{{end}}
			status: 0,
			totalBodyLength: uint32(extralen{{if $command.returns.has_key}} + len(rkey){{end}}{{if $command.returns.has_value}} + len(rvalue){{end}}),
			extrasLength: uint8(extralen),
			{{if $command.returns.has_cas}}cas: rcas,{{end}}
		}

		return rheader, {{if $command.returns.has_key}}rkey{{else}}nil{{end}}, {{if $command.returns.has_value}}rvalue{{else}}nil{{end}}, {{if $op.response.extra_length}}{{if gt $op.response.extra_length 0}}extrabuf[:]{{else}}nil{{end}}{{else}}nil{{end}}
	{{end}}{{end}}
}
{{end}}
