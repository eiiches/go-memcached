// +build !generate

package memcached

import "os"
import "fmt"
import "encoding/binary"

type binaryRequestHandler func(cli Memcached, header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error)

func binaryRequestHandlerTable() []binaryRequestHandler {
	return []binaryRequestHandler{
{{range $command := .binary_commands}}		handle{{$command.name}}Request, // {{$command.opcode}}
{{end}} }
}

{{range $op := .binary_commands}}
func handle{{$op.name}}Request(cli Memcached, header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) {{if $op.request.has_key}}=={{else}}>{{end}} 0 {
		return nil, fmt.Errorf({{if $op.request.has_key}}"{{$op.name}} MUST have key"{{else}}"{{$op.name}} MUST NOT have key"{{end}})
	}

	if len(value) {{if $op.request.has_value}}=={{else}}>{{end}} 0 {
		return nil, fmt.Errorf({{if $op.request.has_value}}"{{$op.name}} MUST have value"{{else}}"{{$op.name}} MUST NOT have value"{{end}})
	}

	{{if $op.request.has_extras}}
		{{if $op.request.has_extras | isTrue}}
			if len(extras) == 0 {
				return nil, fmt.Errorf("{{$op.name}} MUST have extras")
			}
		{{else}}
			if len(extras) != {{$op.request.has_extras.size}} {
			return nil, fmt.Errorf("{{$op.name}} MUST have extras of exactly {{$op.request.has_extras.size}} bytes")
			}
		{{end}}
	{{else}}
		if len(extras) > 0 {
			return nil, fmt.Errorf("{{$op.name}} MUST NOT have extras")
		}
	{{end}}

	{{if $op.request.has_magic}}
		magic := binary.BigEndian.Uint32(extras[{{$op.request.has_magic.offset}}:])
		if magic != MAGIC_DEADBEEF {
			fmt.Fprintf(os.Stderr, "Invalid magic for {{$op.name}}: %+v\n", magic)
			// return nil, fmt.Errorf("Invalid magic for {{$op.name}}: %+v", magic)
		}
	{{end}}

	{{range $extra := $op.request.extras}}
		{{$extra.var}} := binary.BigEndian.{{$extra.type}}(extras[{{$extra.offset}}:])
	{{end}}


	{{with $command := $op.command}}{{with $CommandName := $command.name | snakeToUpperCamel}}
		opts := &{{$CommandName}}Options{
			{{if $command.opts.has_expire}} Expire: binary.BigEndian.Uint32(extras[{{or $op.request.has_expire.offset "\"<NULL>\""}}:]), {{end}}
			{{if $command.opts.has_cas}} Cas: header.cas, {{end}}
			{{range $key, $value := $op.request.opts.extra}}
				{{$key | snakeToUpperCamel}}: {{$value}},
			{{end}}
		}
		{{if $command.returns.has_key}}rkey, {{end}}{{if $command.returns.has_value}}rvalue, {{end}}{{if $command.returns.has_flags}}rflags, {{end}}{{if $command.returns.has_cas}}rcas, {{end}}rerr := cli.{{$CommandName}}({{if $command.args.has_key}}key, {{end}}{{if $command.args.has_value}}value, {{end}}{{range $arg := $op.request.args.extra}}{{$arg}}, {{end}}opts)
	{{end}}{{end}}


	return nil, nil
}
{{end}}
