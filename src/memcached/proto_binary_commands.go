// DO NOT EDIT THIS FILE
// This file is generated from proto_binary_commands.go.in

// +build !generate

package memcached

import "fmt"
import "encoding/binary"

type parseFunc func(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error)

func parseFuncTable() []parseFunc {
	return []parseFunc{
		parseGet, // 0
		parseSet, // 1
		parseAdd, // 2
		parseReplace, // 3
		parseDelete, // 4
		parseIncrement, // 5
		parseDecrement, // 6
		parseQuit, // 7
		parseFlush, // 8
		parseGetQ, // 9
		parseNop, // 10
		parseVersion, // 11
		parseGetK, // 12
		parseGetKQ, // 13
		parseAppend, // 14
		parsePrepend, // 15
		parseStat, // 16
		parseSetQ, // 17
		parseAddQ, // 18
		parseReplaceQ, // 19
		parseDeleteQ, // 20
		parseIncrementQ, // 21
		parseDecrementQ, // 22
		parseQuitQ, // 23
		parseFlushQ, // 24
		parseAppendQ, // 25
		parsePrependQ, // 26
	}
}


func parseGet(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) == 0 {
		return nil, fmt.Errorf("Get MUST have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("Get MUST NOT have value")
	}


	command := Get(key)



	return command, nil
}

func parseSet(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) == 0 {
		return nil, fmt.Errorf("Set MUST have key")
	}
	if len(value) == 0 {
		return nil, fmt.Errorf("Set MUST have value")
	}
	if binary.BigEndian.Uint32(extras[0:]) != MAGIC_DEADBEEF {
		return nil, fmt.Errorf("Invalid magic for Set")
	}

	command := Set(key, value)
	command.WithExpire(binary.BigEndian.Uint32(extras[4:]))
	command.WithCas(header.cas)

	return command, nil
}

func parseAdd(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) == 0 {
		return nil, fmt.Errorf("Add MUST have key")
	}
	if len(value) == 0 {
		return nil, fmt.Errorf("Add MUST have value")
	}
	if binary.BigEndian.Uint32(extras[0:]) != MAGIC_DEADBEEF {
		return nil, fmt.Errorf("Invalid magic for Add")
	}

	command := Add(key, value)
	command.WithExpire(binary.BigEndian.Uint32(extras[4:]))
	command.WithCas(header.cas)

	return command, nil
}

func parseReplace(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) == 0 {
		return nil, fmt.Errorf("Replace MUST have key")
	}
	if len(value) == 0 {
		return nil, fmt.Errorf("Replace MUST have value")
	}
	if binary.BigEndian.Uint32(extras[0:]) != MAGIC_DEADBEEF {
		return nil, fmt.Errorf("Invalid magic for Replace")
	}

	command := Replace(key, value)
	command.WithExpire(binary.BigEndian.Uint32(extras[4:]))
	command.WithCas(header.cas)

	return command, nil
}

func parseDelete(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) == 0 {
		return nil, fmt.Errorf("Delete MUST have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("Delete MUST NOT have value")
	}


	command := Delete(key)



	return command, nil
}

func parseIncrement(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) == 0 {
		return nil, fmt.Errorf("Increment MUST have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("Increment MUST NOT have value")
	}


	command := Increment(key)



	return command, nil
}

func parseDecrement(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) == 0 {
		return nil, fmt.Errorf("Decrement MUST have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("Decrement MUST NOT have value")
	}


	command := Decrement(key)



	return command, nil
}

func parseQuit(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) > 0 {
		return nil, fmt.Errorf("Quit MUST NOT have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("Quit MUST NOT have value")
	}


	command := Quit()



	return command, nil
}

func parseFlush(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) > 0 {
		return nil, fmt.Errorf("Flush MUST NOT have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("Flush MUST NOT have value")
	}


	command := Flush()



	return command, nil
}

func parseGetQ(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) == 0 {
		return nil, fmt.Errorf("GetQ MUST have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("GetQ MUST NOT have value")
	}


	command := Get(key)



	command.WithQuiet(true)

	return command, nil
}

func parseNop(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) > 0 {
		return nil, fmt.Errorf("Nop MUST NOT have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("Nop MUST NOT have value")
	}


	command := Nop()



	return command, nil
}

func parseVersion(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) > 0 {
		return nil, fmt.Errorf("Version MUST NOT have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("Version MUST NOT have value")
	}


	command := Version()



	return command, nil
}

func parseGetK(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) == 0 {
		return nil, fmt.Errorf("GetK MUST have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("GetK MUST NOT have value")
	}


	command := GetK(key)



	return command, nil
}

func parseGetKQ(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) == 0 {
		return nil, fmt.Errorf("GetKQ MUST have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("GetKQ MUST NOT have value")
	}


	command := GetKQ(key)



	return command, nil
}

func parseAppend(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) == 0 {
		return nil, fmt.Errorf("Append MUST have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("Append MUST NOT have value")
	}


	command := Append(key)



	return command, nil
}

func parsePrepend(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) == 0 {
		return nil, fmt.Errorf("Prepend MUST have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("Prepend MUST NOT have value")
	}


	command := Prepend(key)



	return command, nil
}

func parseStat(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) > 0 {
		return nil, fmt.Errorf("Stat MUST NOT have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("Stat MUST NOT have value")
	}


	command := Stat()



	return command, nil
}

func parseSetQ(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) == 0 {
		return nil, fmt.Errorf("SetQ MUST have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("SetQ MUST NOT have value")
	}


	command := Set(key)



	command.WithQuiet(true)

	return command, nil
}

func parseAddQ(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) == 0 {
		return nil, fmt.Errorf("AddQ MUST have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("AddQ MUST NOT have value")
	}


	command := Add(key)



	command.WithQuiet(true)

	return command, nil
}

func parseReplaceQ(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) == 0 {
		return nil, fmt.Errorf("ReplaceQ MUST have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("ReplaceQ MUST NOT have value")
	}


	command := Replace(key)



	command.WithQuiet(true)

	return command, nil
}

func parseDeleteQ(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) == 0 {
		return nil, fmt.Errorf("DeleteQ MUST have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("DeleteQ MUST NOT have value")
	}


	command := Delete(key)



	command.WithQuiet(true)

	return command, nil
}

func parseIncrementQ(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) == 0 {
		return nil, fmt.Errorf("IncrementQ MUST have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("IncrementQ MUST NOT have value")
	}


	command := Increment(key)



	command.WithQuiet(true)

	return command, nil
}

func parseDecrementQ(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) == 0 {
		return nil, fmt.Errorf("DecrementQ MUST have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("DecrementQ MUST NOT have value")
	}


	command := Decrement(key)



	command.WithQuiet(true)

	return command, nil
}

func parseQuitQ(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) > 0 {
		return nil, fmt.Errorf("QuitQ MUST NOT have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("QuitQ MUST NOT have value")
	}


	command := Quit()



	command.WithQuiet(true)

	return command, nil
}

func parseFlushQ(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) > 0 {
		return nil, fmt.Errorf("FlushQ MUST NOT have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("FlushQ MUST NOT have value")
	}


	command := Flush()



	command.WithQuiet(true)

	return command, nil
}

func parseAppendQ(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) == 0 {
		return nil, fmt.Errorf("AppendQ MUST have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("AppendQ MUST NOT have value")
	}


	command := Append(key)



	command.WithQuiet(true)

	return command, nil
}

func parsePrependQ(header *binaryRequestHeader, key []byte, value []byte, extras []byte) (serverCommand, error) {
	if len(key) == 0 {
		return nil, fmt.Errorf("PrependQ MUST have key")
	}
	if len(value) > 0 {
		return nil, fmt.Errorf("PrependQ MUST NOT have value")
	}


	command := Prepend(key)



	command.WithQuiet(true)

	return command, nil
}

