// +build !generate

package memcached

{{range $command := .commands}}

type {{$command.name}}Command struct {
	key    []byte
{{if $command.has_value}}	value  []byte{{end}}
{{if $command.has_expire}}	expire uint32{{end}}
{{if $command.has_cas}}	cas    uint64{{end}}
}

func {{$command.name | snakeToUpperCamel}}(key []byte{{if $command.has_value}}, value []byte{{end}}) *{{$command.name}}Command {
	return &{{$command.name}}Command{
		key:   key,
{{if $command.has_value}}		value: value,{{end}}
	}
}

{{if $command.has_expire}}
func (self *{{$command.name}}Command) WithExpire(expire uint32) *{{$command.name}}Command {
	self.expire = expire
	return self
}
{{end}}
{{if $command.has_cas}}
func (self *{{$command.name}}Command) WithCas(cas uint64) *{{$command.name}}Command {
	self.cas = cas
	return self
}
{{end}}
{{end}}

type serverCommand interface {
	execute(server *MemcachedServer)
}

func (self setCommand) execute(server *MemcachedServer) {
	if self.cas != 0 {
		server.cache.CompareAndSet(self.key, self.value, self.cas, self.expire)
	} else {
		server.cache.Put(self.key, self.value, self.expire)
	}
}

func (self addCommand) execute(server *MemcachedServer) {
}

func (self getCommand) execute(server *MemcachedServer) {
}

func (self replaceCommand) execute(server *MemcachedServer) {
}
